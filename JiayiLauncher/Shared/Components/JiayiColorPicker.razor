@using JiayiLauncher.Appearance
@using JiayiLauncher.Utils

<div class="color-picker-container" @onfocusout="Close" @onfocusout:stopPropagation="true">
    <button class="color-preview" @onclick="() => ToggleVisibility()" style="background-color: @Color.Hex" />

    @if (_showColorPicker)
    {
        <div class="color-picker">
            <div class="color-zone" @onmousedown="CalculateColorZone" @onmousemove="ColorZoneDrag" style="@_zoneBackground">
                <div class="color-pointer" style=@_pointerPosition></div>
            </div>

            <div class="color-info">
                <div class="color-hue-slider" title="Hue">
                    <span class="material-symbols-sharp">invert_colors</span>
                    <JiayiSlider Max="360" Value="@((float)Color.Hue)" Style="width: 84%; height: 4rem;" Step="1" ValueChanged="HueSliderChanged" />
                </div>

                <div class="color-values">
                    @if (_colorMode == ColorMode.RGB)
                    {

                        <div class="color-value" id="rgb">
                            <input type="number" min="0" max="255" step="1" value="@(Color.R)" @onchange="RedChanged">
                            <input type="number" min="0" max="255" step="1" value="@(Color.G)" @onchange="GreenChanged">
                            <input type="number" min="0" max="255" step="1" value="@(Color.B)" @onchange="BlueChanged">
                        </div>
                    }

                    @if (_colorMode == ColorMode.HSL)
                    {

                        <div class="color-value" id="hsl">
                            <input type="number" min="0" max="360" step="1" value="@(Color.Hue)" @onchange="HueChanged">
                            <input type="number" min="0" max="100" step="1" value="@(Math.Round(Color.Saturation * 100))" @onchange="SaturationChanged">
                            <input type="number" min="0" max="100" step="1" value="@(Math.Round(Color.Lightness * 100))" @onchange="LightnessChanged">
                        </div>
                    }

                    @if (_colorMode == ColorMode.HSV)
                    {
                        <div class="color-value" id="hsv">
                            <input type="number" min="0" max="360" step="1" value="@(Color.HSVHue)" @onchange="HSVHueChanged">
                            <input type="number" min="0" max="100" step="1" value="@(Math.Round(Color.HSVSaturation * 100))" @onchange="HSVSaturationChanged">
                            <input type="number" min="0" max="100" step="1" value="@(Math.Round(Color.HSVValue * 100))" @onchange="HSVValueChanged">
                        </div>
                    }

                    @if (_colorMode == ColorMode.HEX)
                    {
                        <div class="color-value" id="hex">
                            <JiayiTextBox Placeholder="#000000" Value="@(Color.Hex)" Style="width: 100%" Changed="HexChanged" />
                        </div>
                    } 

                    <div class="color-mode-select">
                        <span class="material-symbols-sharp" title="Previous color mode"
                        @onclick="() => ChangeColorMode(false)">arrow_left</span>

                        <p class="color-mode">@_colorMode</p>

                        <span class="material-symbols-sharp" title="Next color mode"
                        @onclick="() => ChangeColorMode(true)">arrow_right</span>
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {



    enum ColorMode
    {
        RGB,
        HSL,
        HSV,
        HEX
    }

    [Parameter]
    public TranslatableColor Color { get; set; } = new(255, 0, 0);

    [Parameter]
    public EventCallback<TranslatableColor> ColorChanged { get; set; }

    // Global
    private static ColorMode _colorMode = ColorMode.RGB;

    // Styles
    private bool _showColorPicker = false;
    private string _zoneBackground => "background: linear-gradient(to bottom, transparent, black), " +
                                      $"linear-gradient(to right, white, hsl({Color.Hue}, 100%, 50%))";
    private string _pointerPosition => $"left: calc({(Color.HSVSaturation) * 100}% - 5px);" +
                                        $"bottom: calc({(Color.HSVValue) * 100}% - 5px);"; // 5px is circle radius

    // Color Pointer
    private static Size colorZoneSize = new Size(225, 165);

    private void ChangeColorMode(bool next)
    {
        // Inc/Dec ColorMode
        int color_modes = Enum.GetValues(typeof(ColorMode)).Cast<int>().Max() + 1;

        int direction = (next ? 1 : color_modes - 1);
        int newIdx = ((int)_colorMode + direction) % color_modes;
        _colorMode = (ColorMode)newIdx;
    }

    private void ToggleVisibility(bool? visibility = null)
    {
        _showColorPicker = visibility ?? !_showColorPicker;
        ColorChanged.InvokeAsync(Color);
    }
    private void Close()
    {
        // TODO: FIX CLOSING
        // ToggleVisibility(false);
    }

    private void UpdateEverything()
    {
        InvokeAsync(StateHasChanged); // DUMB
    }

    #region Event Handlers

    // RGB
    private void RedChanged(ChangeEventArgs e)
    {
        if (byte.TryParse((string)(e.Value ?? "0"), out byte result))
        {
            Color.R = result;   
            UpdateEverything();
        }
    }

    private void GreenChanged(ChangeEventArgs e)
    {
        if (byte.TryParse((string)(e.Value ?? "0"), out byte result))
        {
            Color.G = result;
            UpdateEverything();
        }
    }

    private void BlueChanged(ChangeEventArgs e)
    {
        if (byte.TryParse((string)(e.Value ?? "0"), out byte result))
        {
            Color.B = result;
            UpdateEverything();
        }
    }

    // HSL
    private void HueSliderChanged(float value)
    {
        Color.Hue = (int)value;
        UpdateEverything();
    }
    private void HueChanged(ChangeEventArgs e)
    {
        if (float.TryParse((string)(e.Value ?? "0"), out float result))
        {
            HueSliderChanged(result);
            UpdateEverything();
        }
    }

    private void SaturationChanged(ChangeEventArgs e)
    {
        if (float.TryParse((string)(e.Value ?? "0"), out float result))
        {
            Color.Saturation = result / 100f;
            UpdateEverything();
        }
    }

    private void LightnessChanged(ChangeEventArgs e)
    {
        if (float.TryParse((string)(e.Value ?? "0"), out float result))
        {
            Color.Lightness = result / 100f;
            UpdateEverything();
        }
    }

    // HSV
    private void HSVHueChanged(ChangeEventArgs e)
    {
        if (int.TryParse((string)(e.Value ?? "0"), out int result))
        {
            Color.HSVHue = result;
            UpdateEverything();
        }
    }
    private void HSVSaturationChanged(ChangeEventArgs e)
    {
        if (float.TryParse((string)(e.Value ?? "0"), out float result))
        {
            Color.HSVSaturation = result / 100f;
            UpdateEverything();
        }
    }

    private void HSVValueChanged(ChangeEventArgs e)
    {
        if (float.TryParse((string)(e.Value ?? "0"), out float result))
        {
            Color.HSVValue = result / 100f;
            UpdateEverything();
        }
    }

    // Hex
    private void HexChanged(string hex)
    {
        Color.Hex = hex;
        UpdateEverything();
    }

    // Zone
    private void CalculateColorZone(MouseEventArgs e)
    {
        Color.HSVSaturation = (e.OffsetX / colorZoneSize.Width);
        Color.HSVValue = 1 - (e.OffsetY / colorZoneSize.Height);
    }
    private void ColorZoneDrag(MouseEventArgs e)
    {
        if (e.Buttons != 1) return;

        CalculateColorZone(e);
    }

    #endregion
}